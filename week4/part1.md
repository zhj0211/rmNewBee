### **继承、并发**

#### 任务学习目标：

- 类的继承、(纯)虚函数`virtual`、重写`override`、覆盖
- 简单的多线程编程，认识什么是线程/进程，了解锁`mutex`和原子操作`atomic`，学习使用`std::thread`
- 了解回调函数的设计模式

---

#### 任务目标：

实现一个任务管理类，管理一类特定的任务。

被任务管理类管理的**任务**有以下属性：

- 具有一个`int`类型的标识符`key`
- 具有一个回调函数`void callback(int msg)`
- 具有一个运行函数`void run()`
- 具有一个停止函数`void stop()`
- 存有两个`int`类型指针`int *p1, *p2`，监视`p1`指向的变量，当`*p1`不为$0$时，对`*p1`的值进行**运算**，并将其置零，把结果存入`*p2`。(你不一定真的要存储`int *`，这里只是表示你需要操作两个指定地址的变量)

**任务管理类**具有以下属性：

- 存在一个`int`类型的变量`out`
- 当任务管理类中有$n$个任务时，也对应存有$n$个`int`类型的变量$a_1, a_2, ..., a_n$。对于第$i$个任务来说，它应当监视$a_i$(对应上面的`p1`)并操作$a_{i-1}$(对应上面的`p2`)。特别的，第$1$个任务应当监视$a_1$并操作`out`变量

**任务管理类**具有以下功能：

- 线程1：监视变量`out`，当`out`不为$0$时，输出并将其置零
- 线程2：从标准输入`cin`接收控制信号，执行以下操作
  - 添加一个任务至末尾`add {key} {kind}`，其标识符为`key`，任务类型为`kind`，添加后自动运行(例如，你可以开一个线程运行`run`函数)
  - 从末尾删除一个任务`pop`
  - 触发一次回调`callback {key} {msg}`，调用标识符为`key`的任务的回调函数，参数为`msg`

**任务**有以下三种类型

- Task1

  - **运算**：将`(*p1) + 1`的值写入`*p2`，将`*p1`置零
  - `callback(int msg)`：将`*p1`的值修改为`msg`
- Task2

  - 含有一个比例系数`k`，初始为$1$
  - **运算**：将`(*p1) * k`的值写入`*p2`，将`*p1`置零
  - `callback(int msg)`：将`k`的值修改为`msg`，并将`*p1`修改为1
- Task3

  - **运算**：将`*p1`的值暂存为`t`，将`*p1`置零，将`t`写入`*p2`，延迟`1ms`后将`t + 1`写入`*p2`
  - `callback(int msg)`：将`*p1`的值修改为`msg`
- 每种任务写入`*p2`时都需要输出`write {kind}-{key}: {val}`，`val`为写入的值

#### 注意

- 希望同学们自己充分测试后再提交，发现自己代码的bug并修复，**debug能力也是代码能力中非常重要的部分**
- 所有线程的主循环内最好加上`1ms`的延迟
- 注意避免数据竞争，存在竞争的位置使用锁或原子变量
- 子类父类相互转化过程中避免内存泄漏，了解虚析构

---

#### 提示

- 考虑让`Task1-3`继承同一个父类，思考为什么会需要继承？
- 使用`std::vector`存储$a_1,...a_n$是否会出现问题？为什么？
- 思考为什么需要`stop`函数，如果直接析构`thread`会发生什么？
